diff -uprN patches-4.15.0/08-memlogd-logger.patch patches-4.19.0-rc4/08-memlogd-logger.patch
--- patches-4.15.0/08-memlogd-logger.patch	2024-07-29 22:10:42.161190063 +0000
+++ patches-4.19.0-rc4/08-memlogd-logger.patch	2024-08-02 17:42:46.205917229 +0000
@@ -155,7 +155,7 @@ index dac1b8ddb8..a368fe6ba0 100644
      if (rc) return rc;
  
 diff --git a/tools/xl/xl_utils.c b/tools/xl/xl_utils.c
-index 4503ac7ea0..1f646c6400 100644
+index b0d23b2..949d281 100644
 --- a/tools/xl/xl_utils.c
 +++ b/tools/xl/xl_utils.c
 @@ -27,6 +27,8 @@
@@ -164,10 +164,10 @@ index 4503ac7ea0..1f646c6400 100644
  
 +#include "../libs/light/xentoollog_external.h"
 +
- void dolog(const char *file, int line, const char *func, char *fmt, ...)
- {
-     va_list ap;
-@@ -264,14 +266,17 @@ int do_daemonize(char *name, const char *pidfile)
+ #ifndef O_CLOEXEC
+ #define O_CLOEXEC 0
+ #endif
+@@ -268,14 +270,16 @@ int do_daemonize(const char *name, const char *pidfile)
  
      postfork();
  
@@ -175,20 +175,19 @@ index 4503ac7ea0..1f646c6400 100644
 -    if (ret) {
 -        LOG("failed to open logfile %s: %s",fullname,strerror(errno));
 -        exit(-1);
--    }
-+    logfile = xtl_logger_create_external(name);
++    logfile = xtl_logger_create_external((char *)name);
 +    if (logfile < 0) {
-+        ret = libxl_create_logfile(ctx, name, &fullname);
-+        if (ret) {
-+            LOG("failed to open logfile %s: %s",fullname,strerror(errno));
-+            exit(-1);
-+        }
- 
--    CHK_SYSCALL(logfile = open(fullname, O_WRONLY|O_CREAT|O_APPEND, 0644));
++           ret = libxl_create_logfile(ctx, name, &fullname);
++           if (ret) {
++               LOG("failed to open logfile %s: %s",fullname,strerror(errno));
++               exit(-1);
++           }
++          CHK_SYSCALL(logfile = open(fullname, O_WRONLY | O_CREAT | O_APPEND | O_CLOEXEC, 0644));
++          free(fullname);
+     }
+-
+-    CHK_SYSCALL(logfile = open(fullname, O_WRONLY | O_CREAT | O_APPEND | O_CLOEXEC, 0644));
 -    free(fullname);
-+        CHK_SYSCALL(logfile = open(fullname, O_WRONLY|O_CREAT|O_APPEND, 0644));
-+        free(fullname);
-+    }
      assert(logfile >= 3);
  
-     CHK_SYSCALL(nullfd = open("/dev/null", O_RDONLY));
+     CHK_SYSCALL(nullfd = open("/dev/null", O_RDONLY));
\ No newline at end of file
diff -uprN patches-4.15.0/10-bridge-helper-support.patch patches-4.19.0-rc4/10-bridge-helper-support.patch
--- patches-4.15.0/10-bridge-helper-support.patch	2024-07-29 22:10:42.162190044 +0000
+++ patches-4.19.0-rc4/10-bridge-helper-support.patch	2024-08-02 17:42:46.107918486 +0000
@@ -59,7 +59,7 @@
              fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? "no" : script,
 -                              ifname, sizeof ifname, queues > 1, errp);
 +                              ifname, sizeof ifname, 
-+			      tap->has_br ? tap->br : "bn1",
++			      tap->br,
 +			      queues > 1, errp);
              if (fd == -1) {
                  return -1;
diff -uprN patches-4.15.0/12-disable-Werror-to-build-under-gcc-11.2.patch patches-4.19.0-rc4/12-disable-Werror-to-build-under-gcc-11.2.patch
--- patches-4.15.0/12-disable-Werror-to-build-under-gcc-11.2.patch	1970-01-01 00:00:00.000000000 +0000
+++ patches-4.19.0-rc4/12-disable-Werror-to-build-under-gcc-11.2.patch	2024-08-02 17:42:45.938920657 +0000
@@ -0,0 +1,25 @@
+From d3b8b8369c5d48d88ea9ec024cf2988833e1ccaa Mon Sep 17 00:00:00 2001
+From: Petr Fedchenkov <giggsoff@gmail.com>
+Date: Tue, 16 Aug 2022 15:53:35 +0300
+Subject: [PATCH] disable Werror to build under gcc 11.2
+
+Signed-off-by: Petr Fedchenkov <giggsoff@gmail.com>
+---
+ tools/libs/libs.mk | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/tools/libs/libs.mk b/tools/libs/libs.mk
+index 8115aa5..9ed4f5c 100644
+--- a/tools/libs/libs.mk
++++ b/tools/libs/libs.mk
+@@ -14,7 +14,7 @@ MAJOR := $(shell $(XEN_ROOT)/version.sh $(XEN_ROOT)/xen/Makefile)
+ endif
+ MINOR ?= 0
+ 
+-CFLAGS   += -Wmissing-prototypes
++CFLAGS   += -Werror -Wmissing-prototypes
+ CFLAGS   += $(CFLAGS_xeninclude)
+ CFLAGS   += $(foreach lib, $(USELIBS_$(LIBNAME)), $(CFLAGS_libxen$(lib)))
+
+--
+2.34.1
diff -uprN patches-4.15.0/13-qemu-Add-cpu-pin-and-cpumask-options.patch patches-4.19.0-rc4/13-qemu-Add-cpu-pin-and-cpumask-options.patch
--- patches-4.15.0/13-qemu-Add-cpu-pin-and-cpumask-options.patch	2024-07-29 22:10:42.163190024 +0000
+++ patches-4.19.0-rc4/13-qemu-Add-cpu-pin-and-cpumask-options.patch	2024-08-02 17:42:45.965920310 +0000
@@ -123,26 +123,27 @@ index 708583b..a33ee1e 100644
      "-k language     use keyboard layout (for example 'fr' for French)\n",
      QEMU_ARCH_ALL)
 diff --git a/tools/qemu-xen/softmmu/vl.c b/tools/qemu-xen/softmmu/vl.c
-index 4eb9d1f..c7c8abc 100644
+index ea20b23..59ff7c7 100644
 --- a/tools/qemu-xen/softmmu/vl.c
 +++ b/tools/qemu-xen/softmmu/vl.c
-@@ -2868,6 +2868,7 @@ void qemu_init(int argc, char **argv, char **envp)
-     BlockdevOptionsQueue bdo_queue = QSIMPLEQ_HEAD_INITIALIZER(bdo_queue);
-     QemuPluginList plugin_list = QTAILQ_HEAD_INITIALIZER(plugin_list);
-     int mem_prealloc = 0; /* force preallocation of physical target memory */
-+    bool cpu_pin = false;
- 
-     os_set_line_buffering();
- 
-@@ -3638,6 +3639,9 @@ void qemu_init(int argc, char **argv, char **envp)
+@@ -173,6 +173,7 @@ static QemuPluginList plugin_list = QTAILQ_HEAD_INITIALIZER(plugin_list);
+ static BlockdevOptionsQueue bdo_queue = QSIMPLEQ_HEAD_INITIALIZER(bdo_queue);
+ static bool nographic = false;
+ static int mem_prealloc; /* force preallocation of physical target memory */
++static bool cpu_pin = false;
+ static const char *vga_model = NULL;
+ static DisplayOptions dpy;
+ static int num_serial_hds;
+@@ -3360,6 +3361,10 @@ void qemu_init(int argc, char **argv)
              case QEMU_OPTION_nodefaults:
                  has_defaults = 0;
                  break;
 +	    case QEMU_OPTION_cpu_pin:
 +		cpu_pin = true;
 +		break;
++
              case QEMU_OPTION_xen_domid:
-                 if (!(xen_available())) {
+                 if (!(accel_find("xen")) && !(accel_find("kvm"))) {
                      error_report("Option not supported for this target");
 
 base-commit: 9c55fdd5e54c5ea4bf238cee787f13a03eac1c86
diff -uprN patches-4.15.0/14-qemu-Init-CPU-mask-per-VCPU.patch patches-4.19.0-rc4/14-qemu-Init-CPU-mask-per-VCPU.patch
--- patches-4.15.0/14-qemu-Init-CPU-mask-per-VCPU.patch	2024-07-29 22:10:42.163190024 +0000
+++ patches-4.19.0-rc4/14-qemu-Init-CPU-mask-per-VCPU.patch	2024-08-02 17:42:45.991919975 +0000
@@ -24,26 +24,29 @@ index b06f13e..a4b4f11 100644
      AccelState *accelerator;
      CPUArchIdList *possible_cpus;
 diff --git a/tools/qemu-xen/include/hw/core/cpu.h b/tools/qemu-xen/include/hw/core/cpu.h
-index 8f14573..628b31a 100644
+index 397fd3a..1bf357b 100644
 --- a/tools/qemu-xen/include/hw/core/cpu.h
 +++ b/tools/qemu-xen/include/hw/core/cpu.h
-@@ -374,6 +374,8 @@ struct CPUState {
+@@ -344,6 +344,9 @@ struct CPUState {
      bool created;
      bool stop;
      bool stopped;
 +    bool pinned;
 +    uint64_t cpumask;
-     bool unplug;
-     bool crash_occurred;
-     bool exit_request;
++
+ 
+     /* Should CPU start in powered-off state? */
+     bool start_powered_off;
+
 diff --git a/tools/qemu-xen/softmmu/cpus.c b/tools/qemu-xen/softmmu/cpus.c
-index a802e89..da56052 100644
+index 9cbc817..2867325 100644
 --- a/tools/qemu-xen/softmmu/cpus.c
 +++ b/tools/qemu-xen/softmmu/cpus.c
-@@ -2011,6 +2011,23 @@ static void qemu_dummy_start_vcpu(CPUState *cpu)
-                        QEMU_THREAD_JOINABLE);
- }
+@@ -72,6 +72,25 @@ static QemuMutex qemu_global_mutex;
+  */
+ static const AccelOpsClass *cpus_accel;
  
++
 +static inline void cpumask_clear_bit(uint64_t *mask, uint8_t bit)
 +{
 +    *mask &= ~(1ul << bit);
@@ -52,7 +55,7 @@ index a802e89..da56052 100644
 +static inline long cpumask_get_min_bit(uint64_t mask)
 +{
 +  return __builtin_ffsll(mask) - 1;
-+}
++  }
 +
 +static long pick_pcpu(uint64_t *cpumask)
 +{
@@ -61,13 +64,14 @@ index a802e89..da56052 100644
 +    return ret;
 +}
 +
- void qemu_init_vcpu(CPUState *cpu)
++
+ bool cpu_is_stopped(CPUState *cpu)
  {
-     MachineState *ms = MACHINE(qdev_get_machine());
-@@ -2019,6 +2036,20 @@ void qemu_init_vcpu(CPUState *cpu)
-     cpu->nr_threads =  ms->smp.threads;
+     return cpu->stopped || !runstate_is_running();
+@@ -635,6 +654,21 @@ void qemu_init_vcpu(CPUState *cpu)
      cpu->stopped = true;
      cpu->random_seed = qemu_guest_random_seed_thread_part1();
+ 
 +    cpu->pinned = ms->cpu_pin;
 +    static uint64_t vm_cpumask;
 +    uint64_t vcpu_cpumask;
@@ -82,15 +86,18 @@ index a802e89..da56052 100644
 +    }
 +
 +    cpu->cpumask = vcpu_cpumask;
- 
++
      if (!cpu->as) {
          /* If the target cpu hasn't set up any address spaces itself,
+          * give it the default one.
+
+         
 diff --git a/tools/qemu-xen/softmmu/vl.c b/tools/qemu-xen/softmmu/vl.c
-index c7c8abc..f514f59 100644
+index ea20b23..98287f4 100644
 --- a/tools/qemu-xen/softmmu/vl.c
 +++ b/tools/qemu-xen/softmmu/vl.c
-@@ -2829,6 +2829,68 @@ static void create_default_memdev(MachineState *ms, const char *path)
-                             &error_fatal);
+@@ -2631,6 +2631,68 @@ void qmp_x_exit_preconfig(Error **errp)
+     }
  }
  
 +static inline void cpumask_set_bit(uint64_t *mask, uint8_t bit)
@@ -107,15 +114,15 @@ index c7c8abc..f514f59 100644
 +    const char *cur = cpumask_str;
 +    bool range = false;
 +
-+    assert(cpumask_str != NULL);
++   assert(cpumask_str != NULL);
 +
 +    if (strcmp(cpumask_str, "") == 0)
 +        return 0;
 +
 +    if (cpumask_str[0] == '-') {
-+        warn_report("The CPU mask cannot start with -\n");
++       warn_report("The CPU mask cannot start with -\n");
 +        return 0;
-+    }
++   }
 +
 +    uint8_t last_set;
 +    while (*cur) {
@@ -124,7 +131,7 @@ index c7c8abc..f514f59 100644
 +        if (*cur == '-') {
 +            cur++;
 +            range = true;
-+            continue;
++           continue;
 +        }
 +        if (*cur == ',') {
 +            cur++;
@@ -138,7 +145,7 @@ index c7c8abc..f514f59 100644
 +        }
 +        if (end != cur) {
 +            if (num == 0 || num > sizeof(cpumask) * BITS_PER_BYTE)
-+                return 0;
++               return 0;
 +            if (range) {
 +                range = false;
 +                for (int i = last_set + 1; i < num; i++)
@@ -155,14 +162,24 @@ index c7c8abc..f514f59 100644
 +    return cpumask;
 +}
 +
- void qemu_init(int argc, char **argv, char **envp)
+ void qemu_init(int argc, char **argv)
  {
-     int i;
-@@ -4306,6 +4368,19 @@ void qemu_init(int argc, char **argv, char **envp)
- 
-     current_machine->boot_order = boot_order;
- 
-+    current_machine->cpumask = 0;
+     QemuOpts *opts;
+@@ -3357,6 +3419,7 @@ void qemu_init(int argc, char **argv)
+             case QEMU_OPTION_only_migratable:
+                 only_migratable = 1;
+                 break;
++	    	
+             case QEMU_OPTION_nodefaults:
+                 has_defaults = 0;
+                 break;
+@@ -3596,6 +3659,21 @@ void qemu_init(int argc, char **argv)
+     if (cpu_option) {
+         current_machine->cpu_type = parse_cpu_option(cpu_option);
+     }
++
++
++        current_machine->cpumask = 0;
 +    if (current_machine->cpumask_str) {
 +        current_machine->cpumask = cpumask_parse(current_machine->cpumask_str);
 +        if (!current_machine->cpumask) {
@@ -175,9 +192,11 @@ index c7c8abc..f514f59 100644
 +        }
 +    }
 +
-     /* parse features once if machine provides default cpu_type */
-     current_machine->cpu_type = machine_class->default_cpu_type;
-     if (cpu_option) {
+     /* NB: for machine none cpu_type could STILL be NULL here! */
+ 
+     qemu_resolve_machine_memdev();
+
+
 -- 
 2.35.1
 
diff -uprN patches-4.15.0/15-qemu-Set-the-affinity-of-QEMU-threads-according-to-t.patch patches-4.19.0-rc4/15-qemu-Set-the-affinity-of-QEMU-threads-according-to-t.patch
--- patches-4.15.0/15-qemu-Set-the-affinity-of-QEMU-threads-according-to-t.patch	2024-07-29 22:10:42.163190024 +0000
+++ patches-4.19.0-rc4/15-qemu-Set-the-affinity-of-QEMU-threads-according-to-t.patch	2024-08-02 17:42:46.131918179 +0000
@@ -11,91 +11,23 @@ Signed-off-by: Nikolay Martyanov <ohmspe
  tools/qemu-xen/util/qemu-thread-posix.c | 37 +++++++++++++++++++++++++
  3 files changed, 45 insertions(+)
 
-diff --git a/tools/qemu-xen/include/qemu/thread.h b/tools/qemu-xen/include/qemu/thread.h
-index 4baf4d1..3d1a76e 100644
---- a/tools/qemu-xen/include/qemu/thread.h
-+++ b/tools/qemu-xen/include/qemu/thread.h
-@@ -174,6 +174,8 @@ void qemu_event_destroy(QemuEvent *ev);
- void qemu_thread_create(QemuThread *thread, const char *name,
-                         void *(*start_routine)(void *),
-                         void *arg, int mode);
-+/* TODO implemented for POSIX only by now */
-+void qemu_thread_set_affinity(QemuThread *thread, unsigned int cpumask);
- void *qemu_thread_join(QemuThread *thread);
- void qemu_thread_get_self(QemuThread *thread);
- bool qemu_thread_is_self(QemuThread *thread);
+
 diff --git a/tools/qemu-xen/softmmu/cpus.c b/tools/qemu-xen/softmmu/cpus.c
-index da56052..000df00 100644
+index 9cbc817..ab498e4 100644
 --- a/tools/qemu-xen/softmmu/cpus.c
 +++ b/tools/qemu-xen/softmmu/cpus.c
-@@ -2073,6 +2073,12 @@ void qemu_init_vcpu(CPUState *cpu)
-         qemu_dummy_start_vcpu(cpu);
-     }
+@@ -647,6 +647,14 @@ void qemu_init_vcpu(CPUState *cpu)
+     g_assert(cpus_accel != NULL && cpus_accel->create_vcpu_thread != NULL);
+     cpus_accel->create_vcpu_thread(cpu);
  
++
++ 
 +    if(cpu_can_run(cpu))
 +        warn_report("Change a CPU affinity after the CPU may have been running for a while\n");
 +
 +    if (cpu->cpumask)
-+        qemu_thread_set_affinity(cpu->thread, cpu->cpumask);
++        qemu_thread_set_affinity(cpu->thread, cpu->cpumask, 0);
 +
      while (!cpu->created) {
          qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);
      }
-diff --git a/tools/qemu-xen/util/qemu-thread-posix.c b/tools/qemu-xen/util/qemu-thread-posix.c
-index b4c2359..c404ff4 100644
---- a/tools/qemu-xen/util/qemu-thread-posix.c
-+++ b/tools/qemu-xen/util/qemu-thread-posix.c
-@@ -17,6 +17,8 @@
- #include "qemu-thread-common.h"
- #include "qemu/tsan.h"
- 
-+#include "hw/core/cpu.h"
-+
- static bool name_threads;
- 
- void qemu_thread_naming(bool enable)
-@@ -523,6 +525,41 @@ static void *qemu_thread_start(void *args)
-     return r;
- }
- 
-+static inline unsigned get_max_cpu_in_mask(unsigned int cpumask)
-+{
-+    assert(cpumask != 0);
-+    return (sizeof (cpumask) * BITS_PER_BYTE) - __builtin_clz (cpumask) - 1;
-+}
-+
-+void qemu_thread_set_affinity(QemuThread *thread, unsigned int cpumask)
-+{
-+    int err;
-+    size_t cpu_set_size;
-+    cpu_set_t cpu_set;
-+    unsigned int max_pcpu;
-+    unsigned int cpumask_tmp = cpumask;
-+
-+    CPU_ZERO(&cpu_set);
-+
-+    /* set the CPU_SET according to mask */
-+    int cur_pcpu = 0;
-+    while(cpumask_tmp) {
-+        if (cpumask_tmp & 1)
-+            CPU_SET (cur_pcpu, &cpu_set);
-+        cpumask_tmp >>= 1;
-+        cur_pcpu += 1;
-+    }
-+
-+    /* Count the size of the necessary CPU_SET */
-+    max_pcpu = get_max_cpu_in_mask(cpumask);
-+    cpu_set_size = DIV_ROUND_UP(max_pcpu + 1, BITS_PER_BYTE);
-+
-+    err = pthread_setaffinity_np(thread->thread, cpu_set_size, &cpu_set);
-+
-+    if (err)
-+        error_exit (err, __func__);
-+}
-+
- void qemu_thread_create(QemuThread *thread, const char *name,
-                        void *(*start_routine)(void*),
-                        void *arg, int mode)
--- 
-2.35.1
-
diff -uprN patches-4.15.0/x86_64/00-musl-support.patch patches-4.19.0-rc4/x86_64/00-musl-support.patch
--- patches-4.15.0/x86_64/00-musl-support.patch	1970-01-01 00:00:00.000000000 +0000
+++ patches-4.19.0-rc4/x86_64/00-musl-support.patch	2024-08-02 17:46:17.982053760 +0000
@@ -0,0 +1,33 @@
+diff --git a/tools/xenpaging/xenpaging.c b/tools/xenpaging/xenpaging.c
+index d0571cabac..7ad86e3b31 100644
+--- a/tools/xenpaging/xenpaging.c
++++ b/tools/xenpaging/xenpaging.c
+@@ -180,7 +180,7 @@ static int xenpaging_get_tot_pages(struct xenpaging *paging)
+ 
+ static void *init_page(void)
+ {
+-    void *buffer;
++    void *buffer = NULL;
+ 
+     /* Allocated page memory */
+     errno = posix_memalign(&buffer, PAGE_SIZE, PAGE_SIZE);
+--- a/tools/Makefile	2019-09-11 13:15:12.000000000 -0700
++++ b/tools/Makefile	2019-09-11 13:14:58.000000000 -0700
+@@ -245,7 +245,8 @@
+ 		--prefix=$(LIBEXEC) \
+ 		--libdir=$(LIBEXEC_LIB) \
+ 		--includedir=$(LIBEXEC_INC) \
+-		--extra-cflags="-DXC_WANT_COMPAT_EVTCHN_API=1 \
++		--extra-cflags="-DXATTR_SIZE_MAX=65536 \
++                -DXC_WANT_COMPAT_EVTCHN_API=1 \
+ 		-DXC_WANT_COMPAT_GNTTAB_API=1 \
+ 		-DXC_WANT_COMPAT_MAP_FOREIGN_API=1 \
+ 		-DXC_WANT_COMPAT_DEVICEMODEL_API=1 \
+@@ -280,6 +281,7 @@
+ 		--localstatedir=$(localstatedir) \
+ 		--disable-kvm \
+ 		--disable-docs \
++                --disable-werror \
+ 		--disable-guest-agent \
+ 		--python=$(PYTHON) \
+ 		$(CONFIG_QEMUU_EXTRA_ARGS) \
diff -uprN patches-4.15.0/x86_64/01-enable-gmp-patching.patch patches-4.19.0-rc4/x86_64/01-enable-gmp-patching.patch
--- patches-4.15.0/x86_64/01-enable-gmp-patching.patch	1970-01-01 00:00:00.000000000 +0000
+++ patches-4.19.0-rc4/x86_64/01-enable-gmp-patching.patch	2024-08-02 17:46:17.982053760 +0000
@@ -0,0 +1,13 @@
+diff --git a/stubdom/Makefile b/stubdom/Makefile
+index 8cf7131c6a..c6a8051c85 100644
+--- a/stubdom/Makefile
++++ b/stubdom/Makefile
+@@ -178,7 +178,7 @@ gmp-$(XEN_TARGET_ARCH): gmp-$(GMP_VERSION).tar.bz2 $(NEWLIB_STAMPFILE)
+ 	tar xjf $<
+ 	rm $@ -rf || :
+ 	mv gmp-$(GMP_VERSION) $@
+-	#patch -d $@ -p0 < gmp.patch
++	patch -d $@ -p0 < gmp.patch
+ 	cd $@; CPPFLAGS="-isystem $(CROSS_PREFIX)/$(GNU_TARGET_ARCH)-xen-elf/include $(TARGET_CPPFLAGS)" CFLAGS="$(TARGET_CFLAGS)" CC=$(CC) $(GMPEXT) ./configure --disable-shared --enable-static --disable-fft --without-readline --prefix=$(CROSS_PREFIX)/$(GNU_TARGET_ARCH)-xen-elf --libdir=$(CROSS_PREFIX)/$(GNU_TARGET_ARCH)-xen-elf/lib --build=`gcc -dumpmachine` --host=$(GNU_TARGET_ARCH)-xen-elf
+ 	sed -i 's/#define HAVE_OBSTACK_VPRINTF 1/\/\/#define HAVE_OBSTACK_VPRINTF 1/' $@/config.h
+ 	touch $@
diff -uprN patches-4.15.0/x86_64/04-disable-vif-allow-all-iptables.patch patches-4.19.0-rc4/x86_64/04-disable-vif-allow-all-iptables.patch
--- patches-4.15.0/x86_64/04-disable-vif-allow-all-iptables.patch	1970-01-01 00:00:00.000000000 +0000
+++ patches-4.19.0-rc4/x86_64/04-disable-vif-allow-all-iptables.patch	2024-08-02 17:46:17.983053754 +0000
@@ -0,0 +1,10 @@
+--- a/tools/hotplug/Linux/vif-bridge
++++ b/tools/hotplug/Linux/vif-bridge
+@@ -93,7 +93,6 @@ case "$command" in
+         ;;
+ esac
+ 
+-handle_iptable
+ 
+ call_hooks vif post
+ 
diff -uprN patches-4.15.0/x86_64/05-xen-spoofing.patch patches-4.19.0-rc4/x86_64/05-xen-spoofing.patch
--- patches-4.15.0/x86_64/05-xen-spoofing.patch	2024-07-29 22:10:42.164190005 +0000
+++ patches-4.19.0-rc4/x86_64/05-xen-spoofing.patch	2024-08-02 17:42:46.263916485 +0000
@@ -153,19 +153,7 @@ index 97499a0..b500095 100644
          break;
  
      case 1:
-diff --git a/xen/include/asm-x86/hvm/domain.h b/xen/include/asm-x86/hvm/domain.h
-index bcc5621..a506710 100644
---- a/xen/include/asm-x86/hvm/domain.h
-+++ b/xen/include/asm-x86/hvm/domain.h
-@@ -159,6 +159,8 @@ struct hvm_domain {
-     bool_t                 mem_sharing_enabled;
-     bool_t                 qemu_mapcache_invalidate;
-     bool_t                 is_s3_suspended;
-+    bool_t                 spoof_xen;
-+    bool_t                 spoof_viridian;
- 
-     /*
-      * TSC value that VCPUs use to calculate their tsc_offset value.
+
 diff --git a/xen/include/public/arch-x86/cpuid.h b/xen/include/public/arch-x86/cpuid.h
 index ce46305..7e63c55 100644
 --- a/xen/include/public/arch-x86/cpuid.h
@@ -182,21 +170,21 @@ index ce46305..7e63c55 100644
   * Leaf 2 (0x40000x01)
   * EAX[31:16]: Xen major version.
 diff --git a/xen/include/public/hvm/params.h b/xen/include/public/hvm/params.h
-index 36832e4..2be4178 100644
+index 99c40b4..5bec661 100644
 --- a/xen/include/public/hvm/params.h
 +++ b/xen/include/public/hvm/params.h
-@@ -302,7 +302,10 @@
+@@ -290,7 +290,9 @@
  #define HVM_PARAM_MCA_CAP 38
  #define XEN_HVM_MCA_CAP_LMCE   (xen_mk_ullong(1) << 0)
  #define XEN_HVM_MCA_CAP_MASK   XEN_HVM_MCA_CAP_LMCE
-+#define HVM_PARAM_SPOOF_XEN    39
++#define HVM_PARAM_SPOOF_XEN 39
  
 -#define HVM_NR_PARAMS 39
-+#define HVM_PARAM_SPOOF_VIRIDIAN    40
-+
-+#define HVM_NR_PARAMS          41
++#define HVM_PARAM_SPOOF_VIRIDIAN 40
++#define HVM_NR_PARAMS 41
  
  #endif /* __XEN_PUBLIC_HVM_PARAMS_H__ */
+
 diff --git a/tools/xl/xl_parse.c b/tools/xl/xl_parse.c
 index 36832e4..2be4178 100644
 --- a/tools/xl/xl_parse.c
@@ -212,3 +200,18 @@ index 36832e4..2be4178 100644
          switch (xlu_cfg_get_list(config, "viridian",
                                   &viridian, &num_viridian, 1))
          {
+
+diff --git a/xen/arch/x86/include/asm/hvm/domain.h b/xen/arch/x86/include/asm/hvm/domain.h
+index dd9d837..9f2e863 100644
+--- a/xen/arch/x86/include/asm/hvm/domain.h
++++ b/xen/arch/x86/include/asm/hvm/domain.h
+@@ -106,6 +106,9 @@ struct hvm_domain {
+ 
+     bool                   is_s3_suspended;
+ 
++    bool                  spoof_xen;
++    bool                  spoof_virdian;
++
+     /* Compatibility setting for a bug in x2APIC LDR */
+     bool bug_x2apic_ldr_vcpu_id;
+
diff -uprN patches-4.15.0/x86_64/07-patch-seabios.patch patches-4.19.0-rc4/x86_64/07-patch-seabios.patch
--- patches-4.15.0/x86_64/07-patch-seabios.patch	2024-07-29 22:10:42.165189986 +0000
+++ patches-4.19.0-rc4/x86_64/07-patch-seabios.patch	2024-08-02 17:42:46.309915895 +0000
@@ -1,10 +1,12 @@
+diff --git a/tools/firmware/Makefile b/tools/firmware/Makefile
+index 345037b..b70255e 100644
 --- a/tools/firmware/Makefile
 +++ b/tools/firmware/Makefile
-@@ -26,6 +26,7 @@
+@@ -26,6 +26,7 @@ ovmf-dir:
  seabios-dir:
  	GIT=$(GIT) $(XEN_ROOT)/scripts/git-checkout.sh $(SEABIOS_UPSTREAM_URL) $(SEABIOS_UPSTREAM_REVISION) seabios-dir
  	cp seabios-config seabios-dir/.config;
 +	cd seabios-dir && patch -p1 < /patches/x86_64/patch.seabios
  	$(MAKE) -C seabios-dir olddefconfig CC=$(SEABIOSCC) LD=$(SEABIOSLD)
  	rm -f seabios-dir/.version
- 	echo '$(SEABIOS_UPSTREAM_REVISION)' > seabios-dir/.version
+ 	echo '$(SEABIOS_UPSTREAM_REVISION)' > seabios-dir/.version
\ No newline at end of file
diff -uprN patches-4.15.0/x86_64/08-Revert__Revert__vfio_pci-quirks_c__Disable_stolen_memory_for_igd_VFIO__.patch patches-4.19.0-rc4/x86_64/08-Revert__Revert__vfio_pci-quirks_c__Disable_stolen_memory_for_igd_VFIO__.patch
--- patches-4.15.0/x86_64/08-Revert__Revert__vfio_pci-quirks_c__Disable_stolen_memory_for_igd_VFIO__.patch	2024-07-29 22:10:42.165189986 +0000
+++ patches-4.19.0-rc4/x86_64/08-Revert__Revert__vfio_pci-quirks_c__Disable_stolen_memory_for_igd_VFIO__.patch	2024-08-02 17:42:46.236916831 +0000
@@ -1,75 +1,40 @@
-From 9eb4883e57224db64588d724d5764cdccb164c7d Mon Sep 17 00:00:00 2001
-From: Petr Fedchenkov <giggsoff@gmail.com>
-Date: Mon, 11 Oct 2021 17:30:15 +0300
-Subject: [PATCH] Revert "Revert "vfio/pci-quirks.c: Disable stolen memory for
- igd VFIO"" and adopts it to the new qemu with moved vfio_probe_igd_bar4_quirk
- into igd.c.
-
-This reverts commit 93587e3af3a259deac89c12863d93653d69d22b8.
----
- tools/qemu-xen/hw/vfio/igd.c | 64 ++++++++++++++++++++++++++++++---------------------
- 1 file changed, 38 insertions(+), 26 deletions(-)
-
 diff --git a/tools/qemu-xen/hw/vfio/igd.c b/tools/qemu-xen/hw/vfio/igd.c
-index 64e332746b..573cd53803 100644
+index b31ee79..e85d26a 100644
 --- a/tools/qemu-xen/hw/vfio/igd.c
 +++ b/tools/qemu-xen/hw/vfio/igd.c
-@@ -377,14 +377,45 @@ void vfio_probe_igd_bar4_quirk(VFIOPCIDevice *vdev, int nr)
+@@ -252,7 +252,6 @@ static int vfio_igd_gtt_max(VFIOPCIDevice *vdev)
+     uint32_t gmch = vfio_pci_read_config(&vdev->pdev, IGD_GMCH, sizeof(gmch));
+     int ggms, gen = igd_gen(vdev);
+ 
+-    gmch = vfio_pci_read_config(&vdev->pdev, IGD_GMCH, sizeof(gmch));
+     ggms = (gmch >> (gen < 8 ? 8 : 6)) & 0x3;
+     if (gen > 6) {
+         ggms = 1 << ggms;
+@@ -378,16 +377,11 @@ void vfio_probe_igd_bar4_quirk(VFIOPCIDevice *vdev, int nr)
      uint16_t cmd_orig, cmd;
      Error *err = NULL;
-
-+    /* This must be an Intel VGA device. */
-+    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_INTEL, PCI_ANY_ID) ||
-+        !vfio_is_vga(vdev) || nr != 4 ) {
-+        return;
-+    }
-+
-     /*
+ 
+-    /*
 -     * This must be an Intel VGA device at address 00:02.0 for us to even
 -     * consider enabling legacy mode.  The vBIOS has dependencies on the
 -     * PCI bus address.
-+     * IGD is not a standard, they like to change their specs often.  We
-+     * only attempt to support back to SandBridge and we hope that newer
-+     * devices maintain compatibility with generation 8.
-      */
--    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_INTEL, PCI_ANY_ID) ||
+-     */
++   
+     if (!vfio_pci_is(vdev, PCI_VENDOR_ID_INTEL, PCI_ANY_ID) ||
 -        !vfio_is_vga(vdev) || nr != 4 ||
 -        &vdev->pdev != pci_find_device(pci_device_root_bus(&vdev->pdev),
-+    gen = igd_gen(vdev);
-+    if (gen != 6 && gen != 8) {
-+        error_report("IGD device %s is unsupported by IGD quirks, "
-+                     "try SandyBridge or newer", vdev->vbasedev.name);
-+        return;
-+    }
-+
-+    /*
-+     * Regardless of running in UPT or legacy mode, the guest graphics
-+     * driver may attempt to use stolen memory, however only legacy mode
-+     * has BIOS support for reserving stolen memory in the guest VM.
-+     * Emulate the GMCH register in all cases and zero out the stolen
-+     * memory size here. Legacy mode may request allocation and re-write
-+     * this below.
-+     */
-+    gmch = vfio_pci_read_config(&vdev->pdev, IGD_GMCH, 4);
-+    gmch &= ~((gen < 8 ? 0x1f : 0xff) << (gen < 8 ? 3 : 8));
-+
-+    /* GMCH is read-only, emulated */
-+    pci_set_long(vdev->pdev.config + IGD_GMCH, gmch);
-+    pci_set_long(vdev->pdev.wmask + IGD_GMCH, 0);
-+    pci_set_long(vdev->emulated_config_bits + IGD_GMCH, ~0);
+-                                       0, PCI_DEVFN(0x2, 0))) {
+-        return;
++        !vfio_is_vga(vdev) || nr != 4 ) {
 +
-+    /*
-+     * This must be at address 00:02.0 for us to even onsider enabling
-+     * legacy mode.  The vBIOS has dependencies on the PCI bus address.
-+     */
-+    if (&vdev->pdev != pci_find_device(pci_device_root_bus(&vdev->pdev),
-                                        0, PCI_DEVFN(0x2, 0))) {
-         return;
++     	    return;
      }
-@@ -403,18 +434,6 @@ void vfio_probe_igd_bar4_quirk(VFIOPCIDevice *vdev, int nr)
+ 
+     /*
+@@ -404,19 +398,7 @@ void vfio_probe_igd_bar4_quirk(VFIOPCIDevice *vdev, int nr)
          return;
      }
-
+ 
 -    /*
 -     * IGD is not a standard, they like to change their specs often.  We
 -     * only attempt to support back to SandBridge and we hope that newer
@@ -82,36 +47,43 @@ index 64e332746b..573cd53803 100644
 -        return;
 -    }
 -
-     /*
+-    /*
++     /*
       * Most of what we're doing here is to enable the ROM to run, so if
       * there's no ROM, there's no point in setting up this quirk.
-@@ -470,8 +489,6 @@ void vfio_probe_igd_bar4_quirk(VFIOPCIDevice *vdev, int nr)
+      * NB. We only seem to get BIOS ROMs, so a UEFI VM would need CSM support.
+@@ -471,8 +453,7 @@ void vfio_probe_igd_bar4_quirk(VFIOPCIDevice *vdev, int nr)
          goto out;
      }
-
+ 
 -    gmch = vfio_pci_read_config(&vdev->pdev, IGD_GMCH, 4);
 -
++   
      /*
       * If IGD VGA Disable is clear (expected) and VGA is not already enabled,
       * try to enable it.  Probably shouldn't be using legacy mode without VGA,
-@@ -540,12 +557,12 @@ void vfio_probe_igd_bar4_quirk(VFIOPCIDevice *vdev, int nr)
+@@ -541,13 +522,14 @@ void vfio_probe_igd_bar4_quirk(VFIOPCIDevice *vdev, int nr)
       * when IVD (IGD VGA Disable) is clear, but the claim is that it's unused,
       * so let's not waste VM memory for it.
       */
 -    gmch &= ~((gen < 8 ? 0x1f : 0xff) << (gen < 8 ? 3 : 8));
-
+-
++   
      if (vdev->igd_gms) {
          if (vdev->igd_gms <= 0x10) {
              gms_mb = vdev->igd_gms * 32;
              gmch |= vdev->igd_gms << (gen < 8 ? 3 : 8);
+-        } else {
 +            pci_set_long(vdev->pdev.config + IGD_GMCH, gmch);
-         } else {
++
++	} else {
              error_report("Unsupported IGD GMS value 0x%x", vdev->igd_gms);
              vdev->igd_gms = 0;
-@@ -565,11 +582,6 @@ void vfio_probe_igd_bar4_quirk(VFIOPCIDevice *vdev, int nr)
+         }
+@@ -566,11 +548,6 @@ void vfio_probe_igd_bar4_quirk(VFIOPCIDevice *vdev, int nr)
      fw_cfg_add_file(fw_cfg_find(), "etc/igd-bdsm-size",
                      bdsm_size, sizeof(*bdsm_size));
-
+ 
 -    /* GMCH is read-only, emulated */
 -    pci_set_long(vdev->pdev.config + IGD_GMCH, gmch);
 -    pci_set_long(vdev->pdev.wmask + IGD_GMCH, 0);
@@ -120,5 +92,3 @@ index 64e332746b..573cd53803 100644
      /* BDSM is read-write, emulated.  The BIOS needs to be able to write it */
      pci_set_long(vdev->pdev.config + IGD_BDSM, 0);
      pci_set_long(vdev->pdev.wmask + IGD_BDSM, ~0);
---
-2.30.2
diff -uprN patches-4.15.0/x86_64/08-memlogd-logger.patch patches-4.19.0-rc4/x86_64/08-memlogd-logger.patch
--- patches-4.15.0/x86_64/08-memlogd-logger.patch	1970-01-01 00:00:00.000000000 +0000
+++ patches-4.19.0-rc4/x86_64/08-memlogd-logger.patch	2024-08-02 17:46:17.983053754 +0000
@@ -0,0 +1,193 @@
+diff --git a/tools/console/daemon/io.c b/tools/console/daemon/io.c
+index a43c57edad..d0bf636c10 100644
+--- a/tools/console/daemon/io.c
++++ b/tools/console/daemon/io.c
+@@ -27,6 +27,8 @@
+ #include <xen/io/console.h>
+ #include <xen/grant_table.h>
+ 
++#include "../libs/light/xentoollog_external.h"
++
+ #include <stdlib.h>
+ #include <errno.h>
+ #include <string.h>
+@@ -420,6 +422,15 @@ static int create_hv_log(void)
+ {
+ 	char logfile[PATH_MAX];
+ 	int fd;
++
++        fd = xtl_logger_create_external("hypervisor");
++        if (fd < 0) {
++            dolog(LOG_ERR, "Failed to establish connection with the external logger - falling back %d (%s)",
++                            errno, strerror(errno));
++        } else {
++            return fd;
++        }
++
+ 	snprintf(logfile, PATH_MAX-1, "%s/hypervisor.log", log_dir);
+ 	logfile[PATH_MAX-1] = '\0';
+ 
+@@ -444,6 +455,7 @@ static int create_hv_log(void)
+ static int create_console_log(struct console *con)
+ {
+ 	char logfile[PATH_MAX];
++        char logname[PATH_MAX];
+ 	char *namepath, *data, *s;
+ 	int fd;
+ 	unsigned int len;
+@@ -468,9 +480,20 @@ static int create_console_log(struct console *con)
+ 
+ 	snprintf(logfile, PATH_MAX-1, "%s/guest-%s%s.log",
+ 		 log_dir, data, con->log_suffix);
++        snprintf(logname, PATH_MAX-1, "guest_vm-%s%s",
++                 data, con->log_suffix);
+ 
+ 	free(data);
+ 	logfile[PATH_MAX-1] = '\0';
++        logname[PATH_MAX-1] = '\0';
++
++        fd = xtl_logger_create_external(logname);
++        if (fd < 0) {
++            dolog(LOG_ERR, "Failed to establish connection with the external logger - falling back %d (%s)",
++                            errno, strerror(errno));
++        } else {
++            return fd;
++        }
+ 
+ 	fd = open(logfile, O_WRONLY|O_CREAT|O_APPEND, 0644);
+ 	if (fd == -1)
+diff --git a/tools/libs/light/xentoollog_external.h b/tools/libs/light/xentoollog_external.h
+new file mode 100644
+index 0000000000..4b664fc36e
+--- /dev/null
++++ b/tools/libs/light/xentoollog_external.h
+@@ -0,0 +1,68 @@
++#ifndef XENTOOLLOG_EXTERNAL_H
++#define XENTOOLLOG_EXTERNAL_H
++
++#include <unistd.h>
++#include <string.h>
++#include <sys/socket.h>
++#include <sys/un.h>
++
++#define XTL_EXTERNAL_LOGGER_SOCKET          "/var/run/linuxkit-external-logging.sock"
++extern int xtl_logger_create_external(char *name);
++int xtl_logger_create_external(char *name) {
++    int fds[2];
++    int fd;
++    struct sockaddr_un addr;
++    struct msghdr message;
++    struct iovec iov[1];
++    struct cmsghdr *control_message = NULL;
++    char ctrl_buf[CMSG_SPACE(sizeof(int))];
++
++    /* fill out all the required C paperwork */
++    memset(&addr, 0, sizeof(addr));
++    addr.sun_family = AF_UNIX;
++    strcpy(addr.sun_path, XTL_EXTERNAL_LOGGER_SOCKET);
++
++    memset(&message, 0, sizeof(struct msghdr));
++    memset(ctrl_buf, 0, CMSG_SPACE(sizeof(int)));
++    iov[0].iov_base = name;
++    iov[0].iov_len = strlen(name);
++
++    message.msg_name = NULL;
++    message.msg_namelen = 0;
++    message.msg_iov = iov;
++    message.msg_iovlen = 1;
++    message.msg_controllen =  CMSG_SPACE(sizeof(int));
++    message.msg_control = ctrl_buf;
++
++    control_message = CMSG_FIRSTHDR(&message);
++    control_message->cmsg_level = SOL_SOCKET;
++    control_message->cmsg_type = SCM_RIGHTS;
++    control_message->cmsg_len = CMSG_LEN(sizeof(int));
++
++    /* now, do the deed */
++    fd = socket(AF_UNIX, SOCK_DGRAM, 0);
++    if (fd < 0)
++	goto bail;
++
++    if (pipe(fds))
++        goto bail_fd;
++
++    *((int *) CMSG_DATA(control_message)) = fds[0];
++
++    if (connect(fd, (struct sockaddr *)&addr, sizeof(addr)) < 0)
++        goto bail_fd_fds;
++
++    if (sendmsg(fd, &message, 0) >= 0) {
++        return fds[1];
++    }
++
++bail_fd_fds:
++    close(fds[0]);
++    close(fds[1]);
++bail_fd:
++    close(fd);
++bail:
++    return -1;
++}
++
++#endif /* XENTOOLLOG_EXTERNAL_H */
+diff --git a/tools/libs/light/libxl_dm.c b/tools/libs/light/libxl_dm.c
+index dac1b8ddb8..a368fe6ba0 100644
+--- a/tools/libs/light/libxl_dm.c
++++ b/tools/libs/light/libxl_dm.c
+@@ -25,6 +25,8 @@
+ #include <pwd.h>
+ #include <grp.h>
+ 
++#include "xentoollog_external.h"
++
+ static const char *libxl_tapif_script(libxl__gc *gc)
+ {
+ #if defined(__linux__) || defined(__FreeBSD__)
+@@ -49,6 +51,10 @@ static int libxl__create_qemu_logfile(libxl__gc *gc, char *name)
+     char *logfile;
+     int rc, logfile_w;
+ 
++    logfile_w = xtl_logger_create_external(name);
++    if (logfile_w >= 0)
++        return logfile_w;
++
+     rc = libxl_create_logfile(CTX, name, &logfile);
+     if (rc) return rc;
+ 
+diff --git a/tools/xl/xl_utils.c b/tools/xl/xl_utils.c
+index b0d23b2..949d281 100644
+--- a/tools/xl/xl_utils.c
++++ b/tools/xl/xl_utils.c
+@@ -27,6 +27,8 @@
+ #include "xl.h"
+ #include "xl_utils.h"
+ 
++#include "../libs/light/xentoollog_external.h"
++
+ #ifndef O_CLOEXEC
+ #define O_CLOEXEC 0
+ #endif
+@@ -268,14 +270,16 @@ int do_daemonize(const char *name, const char *pidfile)
+ 
+     postfork();
+ 
+-    ret = libxl_create_logfile(ctx, name, &fullname);
+-    if (ret) {
+-        LOG("failed to open logfile %s: %s",fullname,strerror(errno));
+-        exit(-1);
++    logfile = xtl_logger_create_external((char *)name);
++    if (logfile < 0) {
++           ret = libxl_create_logfile(ctx, name, &fullname);
++           if (ret) {
++               LOG("failed to open logfile %s: %s",fullname,strerror(errno));
++               exit(-1);
++           }
++          CHK_SYSCALL(logfile = open(fullname, O_WRONLY | O_CREAT | O_APPEND | O_CLOEXEC, 0644));
++          free(fullname);
+     }
+-
+-    CHK_SYSCALL(logfile = open(fullname, O_WRONLY | O_CREAT | O_APPEND | O_CLOEXEC, 0644));
+-    free(fullname);
+     assert(logfile >= 3);
+ 
+     CHK_SYSCALL(nullfd = open("/dev/null", O_RDONLY));
\ No newline at end of file
diff -uprN patches-4.15.0/x86_64/09-enable-kvm.patch patches-4.19.0-rc4/x86_64/09-enable-kvm.patch
--- patches-4.15.0/x86_64/09-enable-kvm.patch	1970-01-01 00:00:00.000000000 +0000
+++ patches-4.19.0-rc4/x86_64/09-enable-kvm.patch	2024-08-02 17:46:17.983053754 +0000
@@ -0,0 +1,19 @@
+--- a/tools/Makefile.orig
++++ b/tools/Makefile
+@@ -232,7 +232,7 @@
+ 		virtfs='' ; \
+ 	fi ; \
+ 	PKG_CONFIG_PATH=$(XEN_ROOT)/tools/pkg-config$${PKG_CONFIG_PATH:+:$${PKG_CONFIG_PATH}} \
+-	$$source/configure --enable-xen --target-list=i386-softmmu \
++	$$source/configure --enable-xen --target-list=i386-softmmu,$$(uname -m)-softmmu \
+ 		$(QEMU_XEN_ENABLE_DEBUG) \
+ 		$$enable_trace_backend \
+ 		--prefix=$(prefix) \
+@@ -251,7 +251,6 @@
+ 		--mandir=$(LIBEXEC)/share/man \
+ 		--libexecdir=$(LIBEXEC)/libexec \
+ 		--firmwarepath=$(LIBEXEC)/share/qemu-firmware \
+-		--disable-kvm \
+ 		--disable-docs \
+ 		--disable-guest-agent \
+ 		--python=$(PYTHON) \
diff -uprN patches-4.15.0/x86_64/10-bridge-helper-support.patch patches-4.19.0-rc4/x86_64/10-bridge-helper-support.patch
--- patches-4.15.0/x86_64/10-bridge-helper-support.patch	1970-01-01 00:00:00.000000000 +0000
+++ patches-4.19.0-rc4/x86_64/10-bridge-helper-support.patch	2024-08-02 17:46:17.983053754 +0000
@@ -0,0 +1,66 @@
+--- a/tools/qemu-xen/net/tap.c
++++ b/tools/qemu-xen/net/tap.c
+@@ -62,7 +62,7 @@
+     Notifier exit;
+ } TAPState;
+ 
+-static void launch_script(const char *setup_script, const char *ifname,
++static void launch_script(const char *setup_script, const char *ifname, const char *bridge,
+                           int fd, Error **errp);
+ 
+ static void tap_send(void *opaque);
+@@ -300,7 +300,7 @@
+     Error *err = NULL;
+ 
+     if (s->down_script[0]) {
+-        launch_script(s->down_script, s->down_script_arg, s->fd, &err);
++        launch_script(s->down_script, s->down_script_arg, "bn1", s->fd, &err);
+         if (err) {
+             error_report_err(err);
+         }
+@@ -397,7 +397,7 @@
+     return s;
+ }
+ 
+-static void launch_script(const char *setup_script, const char *ifname,
++static void launch_script(const char *setup_script, const char *ifname, const char *bridge,
+                           int fd, Error **errp)
+ {
+     int pid, status;
+@@ -422,6 +422,7 @@
+         parg = args;
+         *parg++ = (char *)setup_script;
+         *parg++ = (char *)ifname;
++	*parg++ = (char *)bridge;
+         *parg = NULL;
+         execv(setup_script, args);
+         _exit(1);
+@@ -607,7 +608,7 @@
+ 
+ static int net_tap_init(const NetdevTapOptions *tap, int *vnet_hdr,
+                         const char *setup_script, char *ifname,
+-                        size_t ifname_sz, int mq_required, Error **errp)
++                        size_t ifname_sz, const char *bridge, int mq_required, Error **errp)
+ {
+     Error *err = NULL;
+     int fd, vnet_hdr_required;
+@@ -629,7 +630,7 @@
+     if (setup_script &&
+         setup_script[0] != '\0' &&
+         strcmp(setup_script, "no") != 0) {
+-        launch_script(setup_script, ifname, fd, &err);
++        launch_script(setup_script, ifname, bridge, fd, &err);
+         if (err) {
+             error_propagate(errp, err);
+             close(fd);
+@@ -918,7 +919,9 @@
+ 
+         for (i = 0; i < queues; i++) {
+             fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? "no" : script,
+-                              ifname, sizeof ifname, queues > 1, errp);
++                              ifname, sizeof ifname, 
++			      tap->br,
++			      queues > 1, errp);
+             if (fd == -1) {
+                 return -1;
+             }
diff -uprN patches-4.15.0/x86_64/11-char-socket-revert.patch patches-4.19.0-rc4/x86_64/11-char-socket-revert.patch
--- patches-4.15.0/x86_64/11-char-socket-revert.patch	1970-01-01 00:00:00.000000000 +0000
+++ patches-4.19.0-rc4/x86_64/11-char-socket-revert.patch	2024-08-02 17:46:17.983053754 +0000
@@ -0,0 +1,24 @@
+diff --git a/tools/qemu-xen/chardev/char-socket.c b/tools/qemu-xen/chardev/char-socket.c
+index ef62dbf..7ad180e 100644
+--- a/tools/qemu-xen/chardev/char-socket.c
++++ b/tools/qemu-xen/chardev/char-socket.c
+@@ -177,16 +177,15 @@ static int tcp_chr_write(Chardev *chr, const uint8_t *buf, int len)
+ 
+         if (ret < 0 && errno != EAGAIN) {
+             if (tcp_chr_read_poll(chr) <= 0) {
+-                /* Perform disconnect and return error. */
+                 tcp_chr_disconnect_locked(chr);
++                return len;
+             } /* else let the read handler finish it properly */
+         }
+ 
+         return ret;
+     } else {
+-        /* Indicate an error. */
+-        errno = EIO;
+-        return -1;
++        /* XXX: indicate an error ? */
++        return len;
+     }
+ }
+ 
diff -uprN patches-4.15.0/x86_64/12-disable-Werror-to-build-under-gcc-11.2.patch patches-4.19.0-rc4/x86_64/12-disable-Werror-to-build-under-gcc-11.2.patch
--- patches-4.15.0/x86_64/12-disable-Werror-to-build-under-gcc-11.2.patch	1970-01-01 00:00:00.000000000 +0000
+++ patches-4.19.0-rc4/x86_64/12-disable-Werror-to-build-under-gcc-11.2.patch	2024-08-02 17:46:17.983053754 +0000
@@ -0,0 +1,25 @@
+From d3b8b8369c5d48d88ea9ec024cf2988833e1ccaa Mon Sep 17 00:00:00 2001
+From: Petr Fedchenkov <giggsoff@gmail.com>
+Date: Tue, 16 Aug 2022 15:53:35 +0300
+Subject: [PATCH] disable Werror to build under gcc 11.2
+
+Signed-off-by: Petr Fedchenkov <giggsoff@gmail.com>
+---
+ tools/libs/libs.mk | 2 +-
+ 1 file changed, 1 insertion(+), 1 deletion(-)
+
+diff --git a/tools/libs/libs.mk b/tools/libs/libs.mk
+index 8115aa5..9ed4f5c 100644
+--- a/tools/libs/libs.mk
++++ b/tools/libs/libs.mk
+@@ -14,7 +14,7 @@ MAJOR := $(shell $(XEN_ROOT)/version.sh $(XEN_ROOT)/xen/Makefile)
+ endif
+ MINOR ?= 0
+ 
+-CFLAGS   += -Wmissing-prototypes
++CFLAGS   += -Werror -Wmissing-prototypes
+ CFLAGS   += $(CFLAGS_xeninclude)
+ CFLAGS   += $(foreach lib, $(USELIBS_$(LIBNAME)), $(CFLAGS_libxen$(lib)))
+
+--
+2.34.1
diff -uprN patches-4.15.0/x86_64/13-qemu-Add-cpu-pin-and-cpumask-options.patch patches-4.19.0-rc4/x86_64/13-qemu-Add-cpu-pin-and-cpumask-options.patch
--- patches-4.15.0/x86_64/13-qemu-Add-cpu-pin-and-cpumask-options.patch	1970-01-01 00:00:00.000000000 +0000
+++ patches-4.19.0-rc4/x86_64/13-qemu-Add-cpu-pin-and-cpumask-options.patch	2024-08-02 17:46:17.983053754 +0000
@@ -0,0 +1,152 @@
+From ccfea3c5e131b3ee623aa5e4e16e13bf8d0291d2 Mon Sep 17 00:00:00 2001
+From: Nikolay Martyanov <ohmspectator@gmail.com>
+Date: Wed, 28 Sep 2022 15:47:11 +0200
+Subject: [PATCH 13/15] qemu: Add 'cpu-pin' and 'cpumask' options.
+
+Add the 'cpumask' option to set the CPU mask for the threads created by QEMU.
+The mask affects all the threads belonging to a VM: both VCPU threads and
+non-VCPU threads. If the option is not provided, it's considered to be '-1',
+which corresponds to all the available CPUs.
+The CPU mask in represented in the form "d[[,-]d]*". E.g. "0-2" or "0-2,5,6".
+CPUs start with 0. For example, the mask "0,3" would mean that only
+physical CPUs 0 and 3 are available for the VM.
+
+Add the 'cpu-pin' option to pin any VCPU thread to a specific CPU. If the
+option is set, any VCPU thread will be assigned to a CPU provided with the
+'cpumask'. If it's not provided, the VPCU threads can migrate from a CPU to a
+CPU within the set of CPUs provided by the 'cpumask' option.
+
+Signed-off-by: Nikolay Martyanov <ohmspectator@gmail.com>
+---
+ tools/qemu-xen/hw/core/machine.c   | 38 ++++++++++++++++++++++++++++++
+ tools/qemu-xen/include/hw/boards.h |  2 ++
+ tools/qemu-xen/qemu-options.hx     | 18 ++++++++++++++
+ tools/qemu-xen/softmmu/vl.c        |  4 ++++
+ 4 files changed, 62 insertions(+)
+
+diff --git a/tools/qemu-xen/hw/core/machine.c b/tools/qemu-xen/hw/core/machine.c
+index 8d1a90c..2f9993e 100644
+--- a/tools/qemu-xen/hw/core/machine.c
++++ b/tools/qemu-xen/hw/core/machine.c
+@@ -372,6 +372,35 @@ static void machine_set_graphics(Object *obj, bool value, Error **errp)
+     ms->enable_graphics = value;
+ }
+ 
++static bool machine_get_cpu_pin(Object *obj, Error **errp)
++{
++    MachineState *ms = MACHINE(obj);
++
++    return ms->cpu_pin;
++}
++
++static void machine_set_cpu_pin(Object *obj, bool value, Error **errp)
++{
++    MachineState *ms = MACHINE(obj);
++
++    ms->cpu_pin = value;
++}
++
++static char *machine_get_cpumask(Object *obj, Error **errp)
++{
++    MachineState *ms = MACHINE(obj);
++
++    return g_strdup(ms->cpumask_str);
++}
++
++static void machine_set_cpumask(Object *obj, const char *value, Error **errp)
++{
++    MachineState *ms = MACHINE(obj);
++
++    g_free(ms->cpumask_str);
++    ms->cpumask_str = g_strdup(value);
++}
++
+ static char *machine_get_firmware(Object *obj, Error **errp)
+ {
+     MachineState *ms = MACHINE(obj);
+@@ -841,6 +870,15 @@ static void machine_class_init(ObjectClass *oc, void *data)
+     object_class_property_set_description(oc, "usb",
+         "Set on/off to enable/disable usb");
+ 
++    object_class_property_add_bool(oc, "cpu-pin",
++        machine_get_cpu_pin, machine_set_cpu_pin);
++    object_class_property_set_description(oc, "cpu-pin",
++        "Set on/off to enable/disable CPU pinning");
++
++    object_class_property_add_str(oc, "cpumask",
++        machine_get_cpumask, machine_set_cpumask);
++    object_class_property_set_description(oc, "cpumask", "CPU Mask");
++
+     object_class_property_add_bool(oc, "graphics",
+         machine_get_graphics, machine_set_graphics);
+     object_class_property_set_description(oc, "graphics",
+diff --git a/tools/qemu-xen/include/hw/boards.h b/tools/qemu-xen/include/hw/boards.h
+index 426ce5f..b06f13e 100644
+--- a/tools/qemu-xen/include/hw/boards.h
++++ b/tools/qemu-xen/include/hw/boards.h
+@@ -294,6 +294,8 @@ struct MachineState {
+     char *kernel_filename;
+     char *kernel_cmdline;
+     char *initrd_filename;
++    bool cpu_pin;
++    char *cpumask_str;
+     const char *cpu_type;
+     AccelState *accelerator;
+     CPUArchIdList *possible_cpus;
+diff --git a/tools/qemu-xen/qemu-options.hx b/tools/qemu-xen/qemu-options.hx
+index 708583b..a33ee1e 100644
+--- a/tools/qemu-xen/qemu-options.hx
++++ b/tools/qemu-xen/qemu-options.hx
+@@ -509,6 +509,24 @@ SRST
+     Preallocate memory when using -mem-path.
+ ERST
+ 
++DEF("cpu-pin", 0, QEMU_OPTION_cpu_pin,
++    "-cpu-pin   pin any VPCU thread to a physical CPU\n",
++    QEMU_ARCH_ALL)
++SRST
++``-cpu-pin``
++    Pin any VCPU thread to a physical CPU.
++ERST
++
++DEF("cpumask", HAS_ARG, QEMU_OPTION_cpumask,
++    "-cpumask=value   define the set of CPUs used by the VM\n",
++    QEMU_ARCH_ALL)
++SRST
++``-cpumask=value``
++    CPU mask in form "d[[,-]d]*". E.g. "0-2" or "0-2,5,6". CPUs start with 0.
++    For example, the mask "0,3" would mean that only physical CPUs 0 and 3 are
++    available for the VM.
++ERST
++
+ DEF("k", HAS_ARG, QEMU_OPTION_k,
+     "-k language     use keyboard layout (for example 'fr' for French)\n",
+     QEMU_ARCH_ALL)
+diff --git a/tools/qemu-xen/softmmu/vl.c b/tools/qemu-xen/softmmu/vl.c
+index ea20b23..59ff7c7 100644
+--- a/tools/qemu-xen/softmmu/vl.c
++++ b/tools/qemu-xen/softmmu/vl.c
+@@ -173,6 +173,7 @@ static QemuPluginList plugin_list = QTAILQ_HEAD_INITIALIZER(plugin_list);
+ static BlockdevOptionsQueue bdo_queue = QSIMPLEQ_HEAD_INITIALIZER(bdo_queue);
+ static bool nographic = false;
+ static int mem_prealloc; /* force preallocation of physical target memory */
++static bool cpu_pin = false;
+ static const char *vga_model = NULL;
+ static DisplayOptions dpy;
+ static int num_serial_hds;
+@@ -3360,6 +3361,10 @@ void qemu_init(int argc, char **argv)
+             case QEMU_OPTION_nodefaults:
+                 has_defaults = 0;
+                 break;
++	    case QEMU_OPTION_cpu_pin:
++		cpu_pin = true;
++		break;
++
+             case QEMU_OPTION_xen_domid:
+                 if (!(accel_find("xen")) && !(accel_find("kvm"))) {
+                     error_report("Option not supported for this target");
+
+base-commit: 9c55fdd5e54c5ea4bf238cee787f13a03eac1c86
+-- 
+2.35.1
+
diff -uprN patches-4.15.0/x86_64/14-qemu-Init-CPU-mask-per-VCPU.patch patches-4.19.0-rc4/x86_64/14-qemu-Init-CPU-mask-per-VCPU.patch
--- patches-4.15.0/x86_64/14-qemu-Init-CPU-mask-per-VCPU.patch	1970-01-01 00:00:00.000000000 +0000
+++ patches-4.19.0-rc4/x86_64/14-qemu-Init-CPU-mask-per-VCPU.patch	2024-08-02 17:46:17.984053749 +0000
@@ -0,0 +1,202 @@
+From bea4aaef5c4dd309799055da9c5d7036579b89e9 Mon Sep 17 00:00:00 2001
+From: Nikolay Martyanov <ohmspectator@gmail.com>
+Date: Wed, 28 Sep 2022 15:52:24 +0200
+Subject: [PATCH 14/15] qemu: Init CPU mask per VCPU.
+
+Signed-off-by: Nikolay Martyanov <ohmspectator@gmail.com>
+---
+ tools/qemu-xen/include/hw/boards.h   |  1 +
+ tools/qemu-xen/include/hw/core/cpu.h |  2 +
+ tools/qemu-xen/softmmu/cpus.c        | 31 ++++++++++++
+ tools/qemu-xen/softmmu/vl.c          | 75 ++++++++++++++++++++++++++++
+ 4 files changed, 109 insertions(+)
+
+diff --git a/tools/qemu-xen/include/hw/boards.h b/tools/qemu-xen/include/hw/boards.h
+index b06f13e..a4b4f11 100644
+--- a/tools/qemu-xen/include/hw/boards.h
++++ b/tools/qemu-xen/include/hw/boards.h
+@@ -296,6 +296,7 @@ struct MachineState {
+     char *initrd_filename;
+     bool cpu_pin;
+     char *cpumask_str;
++    uint64_t cpumask;
+     const char *cpu_type;
+     AccelState *accelerator;
+     CPUArchIdList *possible_cpus;
+diff --git a/tools/qemu-xen/include/hw/core/cpu.h b/tools/qemu-xen/include/hw/core/cpu.h
+index 397fd3a..1bf357b 100644
+--- a/tools/qemu-xen/include/hw/core/cpu.h
++++ b/tools/qemu-xen/include/hw/core/cpu.h
+@@ -344,6 +344,9 @@ struct CPUState {
+     bool created;
+     bool stop;
+     bool stopped;
++    bool pinned;
++    uint64_t cpumask;
++
+ 
+     /* Should CPU start in powered-off state? */
+     bool start_powered_off;
+
+diff --git a/tools/qemu-xen/softmmu/cpus.c b/tools/qemu-xen/softmmu/cpus.c
+index 9cbc817..2867325 100644
+--- a/tools/qemu-xen/softmmu/cpus.c
++++ b/tools/qemu-xen/softmmu/cpus.c
+@@ -72,6 +72,25 @@ static QemuMutex qemu_global_mutex;
+  */
+ static const AccelOpsClass *cpus_accel;
+ 
++
++static inline void cpumask_clear_bit(uint64_t *mask, uint8_t bit)
++{
++    *mask &= ~(1ul << bit);
++}
++
++static inline long cpumask_get_min_bit(uint64_t mask)
++{
++  return __builtin_ffsll(mask) - 1;
++  }
++
++static long pick_pcpu(uint64_t *cpumask)
++{
++    long ret = cpumask_get_min_bit(*cpumask);
++    cpumask_clear_bit(cpumask, ret);
++    return ret;
++}
++
++
+ bool cpu_is_stopped(CPUState *cpu)
+ {
+     return cpu->stopped || !runstate_is_running();
+@@ -635,6 +654,21 @@ void qemu_init_vcpu(CPUState *cpu)
+     cpu->stopped = true;
+     cpu->random_seed = qemu_guest_random_seed_thread_part1();
+ 
++    cpu->pinned = ms->cpu_pin;
++    static uint64_t vm_cpumask;
++    uint64_t vcpu_cpumask;
++    if (!vm_cpumask)
++        vm_cpumask = ms->cpumask;
++    if (!cpu->pinned) {
++        /* If the CPUs are not pinned, assign the whole CPU mask to the VCPU */
++        vcpu_cpumask = vm_cpumask;
++    } else {
++        /* If the CPUs are pinned, pick only one CPU for this VCPU */
++        vcpu_cpumask = 1ull << pick_pcpu(&vm_cpumask);
++    }
++
++    cpu->cpumask = vcpu_cpumask;
++
+     if (!cpu->as) {
+         /* If the target cpu hasn't set up any address spaces itself,
+          * give it the default one.
+
+         
+diff --git a/tools/qemu-xen/softmmu/vl.c b/tools/qemu-xen/softmmu/vl.c
+index ea20b23..98287f4 100644
+--- a/tools/qemu-xen/softmmu/vl.c
++++ b/tools/qemu-xen/softmmu/vl.c
+@@ -2631,6 +2631,68 @@ void qmp_x_exit_preconfig(Error **errp)
+     }
+ }
+ 
++static inline void cpumask_set_bit(uint64_t *mask, uint8_t bit)
++{
++    *mask |= 1ull << bit ;
++}
++
++/* Parse d[[,-]d]* mask (0-2 or 0-2,5,6). CPUs start with 0.
++ * Return 0 in case of error, bitmask if ok
++ */
++static uint64_t cpumask_parse(const char* cpumask_str)
++{
++    uint64_t cpumask = 0;
++    const char *cur = cpumask_str;
++    bool range = false;
++
++   assert(cpumask_str != NULL);
++
++    if (strcmp(cpumask_str, "") == 0)
++        return 0;
++
++    if (cpumask_str[0] == '-') {
++       warn_report("The CPU mask cannot start with -\n");
++        return 0;
++   }
++
++    uint8_t last_set;
++    while (*cur) {
++        unsigned long num;
++        char *end;
++        if (*cur == '-') {
++            cur++;
++            range = true;
++           continue;
++        }
++        if (*cur == ',') {
++            cur++;
++            continue;
++        }
++        num = strtoul(cur, &end, 10);
++        if (num > UCHAR_MAX) {
++            warn_report ("Too big CPU number is provided! Numbers more than %d "
++                         "are not supported at the moment!\n", UCHAR_MAX);
++            return 0;
++        }
++        if (end != cur) {
++            if (num == 0 || num > sizeof(cpumask) * BITS_PER_BYTE)
++               return 0;
++            if (range) {
++                range = false;
++                for (int i = last_set + 1; i < num; i++)
++                    cpumask_set_bit(&cpumask, i);
++            }
++            cpumask_set_bit(&cpumask, num);
++            last_set = num;
++            cur = end;
++            continue;
++        }
++        warn_report("The CPU mask option is broken!\n");
++        return 0;
++    }
++    return cpumask;
++}
++
+ void qemu_init(int argc, char **argv)
+ {
+     QemuOpts *opts;
+@@ -3357,6 +3419,7 @@ void qemu_init(int argc, char **argv)
+             case QEMU_OPTION_only_migratable:
+                 only_migratable = 1;
+                 break;
++	    	
+             case QEMU_OPTION_nodefaults:
+                 has_defaults = 0;
+                 break;
+@@ -3596,6 +3659,21 @@ void qemu_init(int argc, char **argv)
+     if (cpu_option) {
+         current_machine->cpu_type = parse_cpu_option(cpu_option);
+     }
++
++
++        current_machine->cpumask = 0;
++    if (current_machine->cpumask_str) {
++        current_machine->cpumask = cpumask_parse(current_machine->cpumask_str);
++        if (!current_machine->cpumask) {
++            current_machine->cpumask = ~0ull;
++        }
++    }
++    if (current_machine->cpu_pin) {
++        if (!current_machine->cpumask_str) {
++            current_machine->cpumask = ~0ull;
++        }
++    }
++
+     /* NB: for machine none cpu_type could STILL be NULL here! */
+ 
+     qemu_resolve_machine_memdev();
+
+
+-- 
+2.35.1
+
diff -uprN patches-4.15.0/x86_64/15-qemu-Set-the-affinity-of-QEMU-threads-according-to-t.patch patches-4.19.0-rc4/x86_64/15-qemu-Set-the-affinity-of-QEMU-threads-according-to-t.patch
--- patches-4.15.0/x86_64/15-qemu-Set-the-affinity-of-QEMU-threads-according-to-t.patch	1970-01-01 00:00:00.000000000 +0000
+++ patches-4.19.0-rc4/x86_64/15-qemu-Set-the-affinity-of-QEMU-threads-according-to-t.patch	2024-08-02 17:46:17.984053749 +0000
@@ -0,0 +1,33 @@
+From f6861fa011836c9101977e2b0ad1aadaf8d45a57 Mon Sep 17 00:00:00 2001
+From: Nikolay Martyanov <ohmspectator@gmail.com>
+Date: Wed, 28 Sep 2022 16:01:48 +0200
+Subject: [PATCH 15/15] qemu: Set the affinity of QEMU threads according to the
+ CPU mask options.
+
+Signed-off-by: Nikolay Martyanov <ohmspectator@gmail.com>
+---
+ tools/qemu-xen/include/qemu/thread.h    |  2 ++
+ tools/qemu-xen/softmmu/cpus.c           |  6 ++++
+ tools/qemu-xen/util/qemu-thread-posix.c | 37 +++++++++++++++++++++++++
+ 3 files changed, 45 insertions(+)
+
+
+diff --git a/tools/qemu-xen/softmmu/cpus.c b/tools/qemu-xen/softmmu/cpus.c
+index 9cbc817..ab498e4 100644
+--- a/tools/qemu-xen/softmmu/cpus.c
++++ b/tools/qemu-xen/softmmu/cpus.c
+@@ -647,6 +647,14 @@ void qemu_init_vcpu(CPUState *cpu)
+     g_assert(cpus_accel != NULL && cpus_accel->create_vcpu_thread != NULL);
+     cpus_accel->create_vcpu_thread(cpu);
+ 
++
++ 
++    if(cpu_can_run(cpu))
++        warn_report("Change a CPU affinity after the CPU may have been running for a while\n");
++
++    if (cpu->cpumask)
++        qemu_thread_set_affinity(cpu->thread, cpu->cpumask, 0);
++
+     while (!cpu->created) {
+         qemu_cond_wait(&qemu_cpu_cond, &qemu_global_mutex);
+     }
